# 个人报告

在本次课程项目中，我主要负责场景搭建，并协助完成模型加载和骨骼动画，主要处理了模型的纹理和光照问题，以及骨骼动画部分处理报错信息。

##  模型的光照与纹理

我们小组主要使用了三个模型，除球场模型外其他模型都有完整的纹理贴图，而球场模型是由一张木质贴图，其余部分皆是颜色材质，故而很多教程并不适用于球场模型，由我来处理这一块的问题。

下图是我们使用的球场模型，由一块平面和两个篮球架构成，是一个OBJ模型：

![court-obj.png](/images/court-obj.png)

其材质定义文件大致如下：

```mtl
newmtl mtl_0
Ns 96.078431
Ka 0.000000 0.000000 0.000000
Kd 0.611765 0.000000 0.000000
Ks 0.010000 0.010000 0.010000
Ni 1.000000
d 1.000000
illum 2

newmtl mtl_1
Ns 96.078431
Ka 0.000000 0.000000 0.000000
Kd 0.584314 0.584314 0.584314
Ks 0.010000 0.010000 0.010000
Ni 1.000000
d 1.000000
illum 2
map_Kd img-1.jpeg
```

这里定义了两种材质，其中一种没有添加`.jpeg`图片的为颜色材质，另一个贴图材质，如果不区别读取的话，颜色部分就会变成黑色。

如何读取`mtl`文件中的颜色材质呢，流程如下：

首先，`mtl`文件中的颜色材质是由光照因子决定的，Ka代表环境光，Kd代表漫反射光，Ks代表镜面高光。 所以我们需要读取这三个值来代表颜色材质。

首先定义一个结构体存储材质：

```c++
struct Material {
	//材质颜色光照
	glm::vec4 Ka;
	//漫反射
	glm::vec4 Kd;
	//镜反射
	glm::vec4 Ks;
};
```

然后在`Model`类的`processMesh`也就是初始化网格函数中，读取颜色材质：

```c++
// process materials
aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex];
Material mat;
aiColor3D color;
//读取mtl文件顶点数据
material->Get(AI_MATKEY_COLOR_AMBIENT, color);
mat.Ka = glm::vec4(color.r, color.g, color.b,1.0);
material->Get(AI_MATKEY_COLOR_DIFFUSE, color);
mat.Kd = glm::vec4(color.r, color.g, color.b,1.0);
material->Get(AI_MATKEY_COLOR_SPECULAR, color);
mat.Ks = glm::vec4(color.r, color.g, color.b,1.0);
```

然后在`Mesh`中，将该材质同UBO绑定，以传入着色器中使用。

```c++
glUniform1i(glGetUniformLocation(shader.ID, (name + number).c_str()), i);
// ...
glBindBufferRange(GL_UNIFORM_BUFFER,0, uniformBlockIndex,0,sizeof(Material));
```

当然，别忘了在初始化Mesh时定义UBO

```c++
glGenBuffers(1, &uniformBlockIndex);
glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex)+ sizeof(mats), &vertices[0], GL_STATIC_DRAW);
glBindBuffer(GL_UNIFORM_BUFFER, uniformBlockIndex);
glBufferData(GL_UNIFORM_BUFFER,sizeof(mats),(void*)(&mats), GL_STATIC_DRAW);
```

在顶点着色器中，定义一个`uniform`读取上面的材质信息，并将其中的信息传给片段着色器。

```c++
uniform Mat{
	vec4 aAmbient;
	vec4 aDiffuse;
	vec4 aSpecular;
};
```

传到片段着色器中后，在投光光照模型中，将这些颜色信息同本来设定的光照因子相乘。

```c++
#version 330 core
out vec4 FragColor;

struct Light {
    vec3 position;  
  
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
	
    float constant;
    float linear;
    float quadratic;
};

in vec3 FragPos;  
in vec3 Normal;  
in vec2 TexCoords;
//从Mtl中读取的数据
//Material
in vec4 Ambient;
in vec4 Diffuse;
in vec4 Specular;

uniform vec3 viewPos;
uniform Light light;

uniform float shininess;

void main()
{    
	// ambient
    vec3 ambient = light.ambient * Diffuse.rgb;
  	
    // diffuse 
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(light.position - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse =light.diffuse * diff *Diffuse.rgb;  
      
    // attenuation
    float distance    = length(light.position - FragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    
	// specular
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
    vec3 specular = light.specular * spec *   Specular.rgb;  
	
    //ambient  *= attenuation;  
    diffuse   *= attenuation; 
    specular *= attenuation; 
	  
    vec3 result = ambient + diffuse +specular;
    FragColor = vec4(result ,1.0);
}
```

最终实现效果：

![court-render.png](/images/court-render.png)

由于投光衰减参数可能设置的不是很好，所以看着有点暗，但是可以发现，颜色部分都正常显示了，没有受贴图影响。